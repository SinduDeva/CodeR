enable.pmd.analysis=false
pmd.path=C:/dev-tools/code-reviewer/pmd-temp/pmd-bin-7.20.0/bin/pmd.bat
pmd.ruleset.path=config/pmd/changelens-ruleset.xml
enable.structural.impact=true
block.on.must.fix=false
only.changed.lines=true
expand.changed.scope.to.method=false
strict.java=false
strict.spring=false
show.good.patterns=true
show.testing.scope=false
open.report=true
debug=false

# ── Transitive API discovery (BFS call-graph traversal) ───────────────────────
enable.transitive.api.discovery=true
# Depth needs to cover the full call chain from the changed class to the controller.
# A 3-hop chain (util → executor → service → controller) requires depth >= 4 just to reach the
# controller node; 6 gives headroom for deeper layering without meaningful performance cost.
transitive.api.discovery.max.depth=6
# Cap visited files to keep commit-time overhead low (increase if your service layer is very wide)
transitive.api.discovery.max.visited.files=30
transitive.api.discovery.max.controllers=5

# ── Report display ─────────────────────────────────────────────────────────────
# Method-scoped graph (true, default): dependency map shows only files proven to call a
# changed method.  Set false for a broader class-level view.
dependency.graph.scope.method=true

# ── Dependency graph cache ────────────────────────────────────────────────────
# How long (in hours) the on-disk graph cache stays valid.
# 12h covers a full working day without rebuilding on every commit; lower if
# you do heavy structural refactoring within the same day.
graph.cache.ttl.hours=12
# Set to true once to force a full cache rebuild (e.g. after upgrading the tool
# or after a large refactor changes the call graph significantly).
# Reset to false after the next run — or pass --rebuild-graph on the CLI instead.
rebuild.graph.cache=false

# ── Target Java version ───────────────────────────────────────────────────────
# Controls which version-specific rules are active (e.g. pattern-matching instanceof >= 16)
# e.g. 8, 11, 17, 21
java.source.version=17

# ── Advanced / expert knobs (leave at defaults unless you know what you're doing) ─
# transitive.caller.structural.fallback and use.ast.caller.detection work together:
#   structural.fallback enables a broad scan that finds ANY call on a target type when
#   the touched method name is not literally visible in the file (chained calls, delegates).
#   ast.caller.detection controls whether JavaParser (precise) or regex is used for that scan.
# Both are off-path for normal use; the intra-class call expansion handles the common
# private-helper case without needing the broad scan.
#transitive.caller.structural.fallback=false
#use.ast.caller.detection=true
